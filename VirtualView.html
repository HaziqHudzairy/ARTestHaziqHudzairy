<html>

<head>
    <meta charset="utf-8" />
    <title>3D Map with Joysticks for Movement and Rotation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        body {
            margin: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        #joystick-container-move,
        #joystick-container-rotate {
            position: absolute;
            width: 150px;
            height: 150px;
            z-index: 10;
        }

        #joystick-container-move {
            bottom: 50px;
            left: 50px;
        }

        #joystick-container-rotate {
            bottom: 50px;
            right: 50px;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <div id="map"></div>
    <div id="joystick-container-move"></div>
    <div id="joystick-container-rotate"></div>
    <script>
        // Initialize Mapbox
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v12',
            center: [101.662398, 3.118806], // Initial coordinates
            zoom: 150,
            pitch: 90, // Default tilt
            bearing: -90, // Default rotation
            antialias: true,
            accessToken: 'pk.eyJ1IjoiamFpcnkxOTExIiwiYSI6ImNsd3dscGdyMDExb3gyaXBncjlydWRzd2sifQ.vllbvi2AvqhKk6KIs85Mtg',
        });

        // Disable default drag for moving the map
        map.dragPan.disable();
        map.touchZoomRotate.enableRotation();
        map.touchZoomRotate.enable();

        // Polygon boundary from GeoJSON
        const boundaryPolygon = [
            [101.64738755612893, 3.1285276604927645],
            [101.64986936323078, 3.119719619331889],
            [101.65103480562635, 3.1188659153812637],
            [101.65021859361025, 3.118430800811197],
            [101.64937297849514, 3.11749365560172],
            [101.65067252809746, 3.11524717010532],
            [101.65254045209338, 3.1099995854748954],
            [101.65482572145748, 3.111519571076286],
            [101.65790333010443, 3.1134663099523436],
            [101.66195800458485, 3.116351353104534],
            [101.66321275186533, 3.1179224338463314],
            [101.66335063126661, 3.1187339445736626],
            [101.66148321332452, 3.119906556364171],
            [101.66104041750026, 3.1210211616459844],
            [101.66179021975944, 3.1245297151786957],
            [101.66165413776821, 3.128469100380755],
            [101.660967005425, 3.1315384151605485],
            [101.65839489809252, 3.1346028217926403],
            [101.65411358951718, 3.1348735186712418],
            [101.64887420755485, 3.1311816111767143],
            [101.64738755612893, 3.1285276604927645]
        ];

        // Add boundary as a layer
        map.on('load', () => {
            map.addSource('boundary', {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [boundaryPolygon]
                    }
                }
            });

            map.addLayer({
                id: 'boundary',
                type: 'line',
                source: 'boundary',
                paint: {
                    'line-color': '#FF0000',
                    'line-width': 2
                }
            });
        });

        // Load the restricted area polygon from GeoJSON
        fetch('asset/VR/Lake.geojson') // Replace with your actual GeoJSON file path
            .then(response => response.json())
            .then(data => {
                restrictedPolygon = data.features[0].geometry.coordinates[0]; // Extract the first polygon's coordinates
            })
            .catch(error => console.error('Error loading GeoJSON:', error));


        // Function to check if a point is within the polygon
        function isPointInPolygon(point, polygon) {
            const [lng, lat] = point;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];
                const intersect = ((yi > lat) !== (yj > lat)) &&
                    (lng < ((xj - xi) * (lat - yi)) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Create an HTML element for the center dot marker
        const centerDotElement = document.createElement('div');
        centerDotElement.style.width = '100px'; // Set the width of the dot
        centerDotElement.style.height = '100px'; // Set the height of the dot
        centerDotElement.style.backgroundImage = 'url("asset/VR/car.png")'; // Replace with your image path or URL
        centerDotElement.style.backgroundSize = 'cover';
        centerDotElement.style.borderRadius = '50%'; // Optional: Make it circular if the image isn't circular
        centerDotElement.style.pointerEvents = 'none'; // Prevent interactions with the marker

        // Create the marker with the custom element
        const centerDot = new mapboxgl.Marker({
            element: centerDotElement, // Use the custom HTML element
            anchor: 'center' // Ensure the image is centered
        })
            .setLngLat(map.getCenter()) // Set initial position to map center
            .addTo(map);

        // Joystick for Movement
        const moveJoystick = nipplejs.create({
            zone: document.getElementById('joystick-container-move'),
            mode: 'static',
            position: { left: '50%', bottom: '50%' },
            color: 'blue',
            size: 150
        });

        const movementSpeed = 0.0000001;
        let movementDirection = null;

        moveJoystick.on('move', function (evt, data) {
            if (data.angle && data.distance) {
                const angle = data.angle.degree;
                const distance = data.distance;
                movementDirection = { angle, distance };
            }
        });

        moveJoystick.on('end', function () {
            movementDirection = null;
        });

        

        let lastTimestamp = 0;

        function updateMovement(timestamp) {
            if (lastTimestamp === 0 || timestamp - lastTimestamp > 24) {
                if (movementDirection) {
                    const center = map.getCenter();
                    const mapBearing = map.getBearing();
                    const adjustedAngle = (movementDirection.angle - mapBearing + 360) % 360;
                    const radianAngle = (adjustedAngle * Math.PI) / 180;

                    const deltaLng = movementSpeed * Math.cos(radianAngle) * movementDirection.distance;
                    const deltaLat = movementSpeed * Math.sin(radianAngle) * movementDirection.distance;

                    const newCenter = [center.lng + deltaLng, center.lat + deltaLat];
                    if (isPointInPolygon(newCenter, boundaryPolygon) && !isPointInBuilding(newCenter) && !isPointInPolygon(newCenter, restrictedPolygon)) {
                        map.setCenter(newCenter); // Update map center
                        centerDot.setLngLat(newCenter); // Update the center dot
                    }
                }
                lastTimestamp = timestamp;
            }
            requestAnimationFrame(updateMovement);
        }
        requestAnimationFrame(updateMovement);



        // Joystick for Rotation
        const rotateJoystick = nipplejs.create({
            zone: document.getElementById('joystick-container-rotate'),
            mode: 'static',
            position: { right: '50%', bottom: '50%' },
            color: 'red',
            size: 150
        });

        const rotationSpeed = 0.65;
        let rotationDirection = null;

        rotateJoystick.on('move', function (evt, data) {
            if (data.angle) {
                const angle = data.angle.degree;
                rotationDirection = angle >= 90 && angle <= 270 ? -1 : 1; // Left or right
            }
        });

        rotateJoystick.on('end', function () {
            rotationDirection = null;
        });

        function animate() {

            if (rotationDirection !== null) {
                map.setBearing(map.getBearing() + rotationSpeed * rotationDirection);
            }
            // Movement and rotation logic
            requestAnimationFrame(animate);
        }
        animate();


        map.on('load', function () {
            const layers = map.getStyle().layers;
            const labelLayerId = layers.find(layer => layer.type === 'symbol' && layer.layout['text-field'])?.id;


            map.addLayer({
                id: '3d-buildings',
                source: 'composite',
                'source-layer': 'building',
                filter: ['==', 'extrude', 'true'],
                type: 'fill-extrusion',
                minzoom: 15,
                paint: {
                    'fill-extrusion-color': '#aaa',
                    'fill-extrusion-height': ['get', 'height'],
                    'fill-extrusion-base': ['get', 'min_height'],
                    'fill-extrusion-opacity': 0.7
                }
            }, labelLayerId);
        });

        function isPointInBuilding(point) {
            const features = map.queryRenderedFeatures(map.project(point), {
                layers: ['3d-buildings'], // Use the 3D building layer ID
            });

            // Check if any features (buildings) are at this point
            return features && features.length > 0;
        }
    </script>

<script type="module">
    async function loadEntities() {
        try {
            const response = await fetch('./entities.json');
            const json = await response.json();

            const entities = Object.values(json.entities)
                .flatMap(category => Object.values(category));

            entities.forEach(validateAndAddModel);
        } catch (error) {
            console.error('Error loading entities:', error);
        }
    }

    function validateAndAddModel(entity) {
        const { latitude, longitude, model, scale, name } = entity;

        if (!latitude || !longitude || !model || !scale) {
            console.warn(`Skipping invalid entity: ${name}`, entity);
            return;
        }

        addModelToMap(entity);
    }

    function createModelTransform(entity) {
        const { latitude, longitude, scale } = entity;
        const modelOrigin = [longitude, latitude];
        const modelAltitude = 0;

        const mercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(modelOrigin, modelAltitude);
        const scaleFactor = mercatorCoordinate.meterInMercatorCoordinateUnits() * parseFloat(scale.split(' ')[0] || 1);

        return {
            translateX: mercatorCoordinate.x,
            translateY: mercatorCoordinate.y,
            translateZ: mercatorCoordinate.z,
            rotateX: Math.PI / 2,
            rotateY: 0,
            rotateZ: 0,
            scale: scaleFactor
        };
    }

    function loadTexture(url) {
        const loader = new THREE.TextureLoader();
        const texture = loader.load(url);
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
        return texture;
    }

    function addModelToMap(entity) {
        const { model, name } = entity;
        const modelTransform = createModelTransform(entity);
        const gradientMap = loadTexture('asset/middle_button/threeTone.jpg');

        const customLayer = {
            id: `3d-model-${name}`,
            type: 'custom',
            renderingMode: '3d',
            onAdd: function (map, gl) {
                this.map = map;
                this.scene = new THREE.Scene();
                this.camera = new THREE.Camera();
                this.renderer = new THREE.WebGLRenderer({
                    canvas: map.getCanvas(),
                    context: gl,
                    antialias: true
                });
                this.renderer.autoClear = false;
                this.clock = new THREE.Clock();
                this.mixer = null;

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 10, 0);
                this.scene.add(directionalLight);

                const ambientLight = new THREE.AmbientLight(0x404040, 1);
                this.scene.add(ambientLight);

                const loader = new THREE.GLTFLoader();
                loader.load(
                    model,
                    (gltf) => {
                        const loadedModel = gltf.scene;
                        loadedModel.traverse(child => {
                            if (child.isMesh) {
                                const originalMaterial = child.material;
                                child.material = new THREE.MeshToonMaterial({
                                    color: originalMaterial.color || 0xffffff,
                                    map: originalMaterial.map || null,
                                    gradientMap: gradientMap,
                                    emissive: originalMaterial.emissive || 0x000000,
                                    emissiveMap: originalMaterial.emissiveMap || null
                                });
                            }
                        });

                        this.scene.add(loadedModel);

                        if (gltf.animations.length > 0) {
                            this.mixer = new THREE.AnimationMixer(loadedModel);
                            gltf.animations.forEach(clip => this.mixer.clipAction(clip).play());
                        }
                    },
                    undefined,
                    (error) => console.error(`Error loading model for ${name}:`, error)
                );
            },
            render: function (gl, matrix) {
                const rotationX = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), modelTransform.rotateX);
                const rotationY = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), modelTransform.rotateY);
                const rotationZ = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), modelTransform.rotateZ);

                const m = new THREE.Matrix4().fromArray(matrix);
                const l = new THREE.Matrix4()
                    .makeTranslation(modelTransform.translateX, modelTransform.translateY, modelTransform.translateZ)
                    .scale(new THREE.Vector3(modelTransform.scale, -modelTransform.scale, modelTransform.scale))
                    .multiply(rotationX)
                    .multiply(rotationY)
                    .multiply(rotationZ);

                this.camera.projectionMatrix = m.multiply(l);

                if (this.mixer) {
                    const delta = this.clock.getDelta();
                    this.mixer.update(delta);
                }

                this.renderer.resetState();
                this.renderer.render(this.scene, this.camera);
                this.map.triggerRepaint();
            }
        };

        map.addLayer(customLayer);
    }

//     async function loadAndScatterTrees() {
//     try {
//         const randomCoordinates = await fetch('asset/VR/random_coordinates.json').then(res => res.json());
//         const treeModelUrl = 'asset/VR/tree.glb';

//         randomCoordinates.coordinates.forEach((coordinate, index) => {
//             addModelToMap({
//                 latitude: coordinate[0],
//                 longitude: coordinate[1],
//                 model: treeModelUrl,
//                 scale: (0.6 + Math.random() * 0.4).toFixed(2),
//                 name: `tree-${index}`
//             });
//         });
//     } catch (error) {
//         console.error('Error scattering trees:', error);
//     }
// }

loadEntities();

// map.on('style.load', loadAndScatterTrees);
</script>


</body>

</html>