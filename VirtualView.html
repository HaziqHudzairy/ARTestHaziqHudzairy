<html>

<head>
    <meta charset="utf-8" />
    <title>3D Map with Joysticks for Movement and Rotation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        body {
            margin: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        #joystick-container-move,
        #joystick-container-rotate {
            position: absolute;
            width: 150px;
            height: 150px;
            z-index: 10;
        }

        #joystick-container-move {
            bottom: 50px;
            left: 50px;
        }

        #joystick-container-rotate {
            bottom: 50px;
            right: 50px;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <div id="map"></div>
    <div id="joystick-container-move"></div>
    <div id="joystick-container-rotate"></div>
    <script>
        // Initialize Mapbox
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v12',
            center: [101.662398,3.118806], // Initial coordinates
            zoom: 150,
            pitch: 90, // Default tilt
            bearing: -90, // Default rotation
            antialias: true,
            accessToken: 'pk.eyJ1IjoiamFpcnkxOTExIiwiYSI6ImNsd3dscGdyMDExb3gyaXBncjlydWRzd2sifQ.vllbvi2AvqhKk6KIs85Mtg',
        });

        // Disable default drag for moving the map
        map.dragPan.disable();
        map.touchZoomRotate.enableRotation();
        map.touchZoomRotate.enable();

        // Polygon boundary from GeoJSON
        const boundaryPolygon = [
            [101.64738755612893, 3.1285276604927645],
            [101.64986936323078, 3.119719619331889],
            [101.65103480562635, 3.1188659153812637],
            [101.65021859361025, 3.118430800811197],
            [101.64937297849514, 3.11749365560172],
            [101.65067252809746, 3.11524717010532],
            [101.65254045209338, 3.1099995854748954],
            [101.65482572145748, 3.111519571076286],
            [101.65790333010443, 3.1134663099523436],
            [101.66195800458485, 3.116351353104534],
            [101.66321275186533, 3.1179224338463314],
            [101.66335063126661, 3.1187339445736626],
            [101.66148321332452, 3.119906556364171],
            [101.66104041750026, 3.1210211616459844],
            [101.66179021975944, 3.1245297151786957],
            [101.66165413776821, 3.128469100380755],
            [101.660967005425, 3.1315384151605485],
            [101.65839489809252, 3.1346028217926403],
            [101.65411358951718, 3.1348735186712418],
            [101.64887420755485, 3.1311816111767143],
            [101.64738755612893, 3.1285276604927645]
        ];

        // Add boundary as a layer
        map.on('load', () => {
            map.addSource('boundary', {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [boundaryPolygon]
                    }
                }
            });

            map.addLayer({
                id: 'boundary',
                type: 'line',
                source: 'boundary',
                paint: {
                    'line-color': '#FF0000',
                    'line-width': 2
                }
            });

            // Add a red dot for user position
            const userPosition = [101.662398, 3.118806];
            map.addSource('user-position', {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: userPosition
                    }
                }
            });

            map.addLayer({
                id: 'user-position',
                type: 'circle',
                source: 'user-position',
                paint: {
                    'circle-radius': 15,
                    'circle-color': '#2980b9'
                }
            });
        });

        // Function to update user position
        function updateUserPosition(newPosition) {
            const userSource = map.getSource('user-position');
            if (userSource) {
                userSource.setData({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: newPosition
                    }
                });
            }
        }

        // Function to check if a point is within the polygon
        function isPointInPolygon(point, polygon) {
            const [lng, lat] = point;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];
                const intersect = ((yi > lat) !== (yj > lat)) &&
                    (lng < ((xj - xi) * (lat - yi)) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Joystick for Movement
        const moveJoystick = nipplejs.create({
            zone: document.getElementById('joystick-container-move'),
            mode: 'static',
            position: { left: '50%', bottom: '50%' },
            color: 'blue',
            size: 150
        });

        const movementSpeed = 0.00000003;
        let movementDirection = null;

        moveJoystick.on('move', function (evt, data) {
            if (data.angle && data.distance) {
                const angle = data.angle.degree;
                const distance = data.distance;
                movementDirection = { angle, distance };
            }
        });

        moveJoystick.on('end', function () {
            movementDirection = null;
        });

        setInterval(() => {
            if (movementDirection) {
                const center = map.getCenter();
                const mapBearing = map.getBearing();
                const adjustedAngle = (movementDirection.angle - mapBearing + 360) % 360;
                const radianAngle = (adjustedAngle * Math.PI) / 180;

                const deltaLng = movementSpeed * Math.cos(radianAngle) * movementDirection.distance;
                const deltaLat = movementSpeed * Math.sin(radianAngle) * movementDirection.distance;

                const newCenter = [center.lng + deltaLng, center.lat + deltaLat];

                // Check if the point is inside a building
                isPointInBuilding(newCenter, (insideBuilding) => {
                    if (!insideBuilding && isPointInPolygon(newCenter, boundaryPolygon)) {
                        map.setCenter(newCenter);
                        updateUserPosition(newCenter);
                    } else {
                        //console.log('Movement blocked: Point intersects a building or is outside the boundary.');
                    }
                });
            }
        }, 50);


        // Joystick for Rotation
        const rotateJoystick = nipplejs.create({
            zone: document.getElementById('joystick-container-rotate'),
            mode: 'static',
            position: { right: '50%', bottom: '50%' },
            color: 'red',
            size: 150
        });

        const rotationSpeed = 0.65;
        let rotationDirection = null;

        rotateJoystick.on('move', function (evt, data) {
            if (data.angle) {
                const angle = data.angle.degree;
                rotationDirection = angle >= 90 && angle <= 270 ? -1 : 1; // Left or right
            }
        });

        rotateJoystick.on('end', function () {
            rotationDirection = null;
        });

        function animate() {
            if (rotationDirection !== null) {
                map.setBearing(map.getBearing() + rotationSpeed * rotationDirection);
            }
            // Skip repaint if no changes
            if (rotationDirection !== null || movementDirection !== null) {
                requestAnimationFrame(animate);
            }
        }
        animate();



        map.on('load', function () {
            const layers = map.getStyle().layers;
            const labelLayerId = layers.find(layer => layer.type === 'symbol' && layer.layout['text-field'])?.id;


            map.addLayer({
                id: '3d-buildings',
                source: 'composite',
                'source-layer': 'building',
                filter: ['==', 'extrude', 'true'],
                type: 'fill-extrusion',
                minzoom: 15,
                paint: {
                    'fill-extrusion-color': '#aaa',
                    'fill-extrusion-height': ['get', 'height'],
                    'fill-extrusion-base': ['get', 'min_height'],
                    'fill-extrusion-opacity': 0.7
                }
            }, labelLayerId);
        });

        function isPointInBuilding(point, callback) {
            const features = map.queryRenderedFeatures(map.project(point), {
                layers: ['3d-buildings'], // Use the 3D building layer ID
            });

            if (features && features.length > 0) {
                // If there are features (buildings) at this point, return true
                callback(true);
            } else {
                // No buildings at this point
                callback(false);
            }
        }

    </script>

    <script type="module">

        const response = await fetch('./entities.json');
        const json = await response.json();

        // Combine all entities into one object
        const entities = {
            ...json.entities.facilities,
            ...json.entities.faculties,
            ...json.entities.libraries,
            ...json.entities.residentialColleges,
            ...json.entities.sportsAndRecreation
        };

        function addModel(entity) {
            const { latitude, longitude, model, scale, name } = entity;

            // Validate entity data
            if (!latitude || !longitude || !model || !scale) {
                console.error(`Missing data for entity: ${name}`, entity);
                return;
            }

            const modelOrigin = [longitude, latitude];
            const modelAltitude = 0;
            const modelRotation = [Math.PI / 2, 0, 0];

            const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
                modelOrigin,
                modelAltitude
            );

            const modelTransform = {
                translateX: modelAsMercatorCoordinate.x,
                translateY: modelAsMercatorCoordinate.y,
                translateZ: modelAsMercatorCoordinate.z,
                rotateX: modelRotation[0],
                rotateY: modelRotation[1],
                rotateZ: modelRotation[2],
                scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits() * (parseFloat(scale.split(' ')[0]) || 1)
            };

            const customLayer = {
                id: `3d-model-${name}`,
                type: 'custom',
                renderingMode: '3d',
                onAdd: function (map, gl) {
                    this.map = map;
                    this.camera = new THREE.Camera();
                    this.scene = new THREE.Scene();
                    this.mixer = null; // Animation mixer for handling animations

                    const light1 = new THREE.DirectionalLight(0xffffff);
                    light1.position.set(0, -70, 100).normalize();
                    this.scene.add(light1);

                    const light2 = new THREE.DirectionalLight(0xffffff);
                    light2.position.set(0, 70, 100).normalize();
                    this.scene.add(light2);

                    const loader = new THREE.GLTFLoader();
                    loader.load(
                        model, // Use the `model` directly as the path
                        (gltf) => {
                            const loadedModel = gltf.scene;
                            this.scene.add(loadedModel);
                            console.log(`Model loaded successfully for: ${name}`);

                            // Initialize animation mixer and start animations
                            if (gltf.animations && gltf.animations.length > 0) {
                                this.mixer = new THREE.AnimationMixer(loadedModel);
                                gltf.animations.forEach((clip) => {
                                    const action = this.mixer.clipAction(clip);
                                    action.play(); // Start the animation
                                });
                            }
                        },
                        undefined,
                        (error) => {
                            console.error(`Error loading model for ${name}:`, error);
                        }
                    );

                    this.renderer = new THREE.WebGLRenderer({
                        canvas: map.getCanvas(),
                        context: gl,
                        antialias: true
                    });

                    this.renderer.autoClear = false;
                    this.clock = new THREE.Clock(); // Clock for animation updates
                },
                render: function (gl, matrix) {
                    const rotationX = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(1, 0, 0),
                        modelTransform.rotateX
                    );
                    const rotationY = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(0, 1, 0),
                        modelTransform.rotateY
                    );
                    const rotationZ = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(0, 0, 1),
                        modelTransform.rotateZ
                    );

                    const m = new THREE.Matrix4().fromArray(matrix);
                    const l = new THREE.Matrix4()
                        .makeTranslation(
                            modelTransform.translateX,
                            modelTransform.translateY,
                            modelTransform.translateZ
                        )
                        .scale(
                            new THREE.Vector3(
                                modelTransform.scale,
                                -modelTransform.scale,
                                modelTransform.scale
                            )
                        )
                        .multiply(rotationX)
                        .multiply(rotationY)
                        .multiply(rotationZ);

                    this.camera.projectionMatrix = m.multiply(l);

                    // Update animations
                    if (this.mixer) {
                        const delta = this.clock.getDelta(); // Get time delta for the animation update
                        this.mixer.update(delta);
                    }

                    this.renderer.resetState();
                    this.renderer.render(this.scene, this.camera);
                    this.map.triggerRepaint();
                }
            };

            map.addLayer(customLayer);
        }


        // Loop through all entities and add them to the map
        Object.values(entities).forEach(addModel);


    </script>
</body>

</html>